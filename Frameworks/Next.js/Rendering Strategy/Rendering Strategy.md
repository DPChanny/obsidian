---
type: framework
---
## 1. Next.js는 왜 만들어졌는가?

React는 선언적이고 유연한 UI 라이브러리지만,

**렌더링 전략에 대한 결정은 모두 개발자에게 떠넘긴다.**

- 화면은 언제 그려지는가?
- 데이터는 어디서 불러오는가?
- 초기 렌더링은 서버에서 할 것인가, 클라이언트에서 할 것인가?
- HTML은 어떻게 SEO를 위해 최적화할 것인가?

이 질문에 대한 일관된 해답이 없기 때문에,

**React로 만든 앱은 서버도 클라이언트도 아닌 "중간지대"에서 떠돈다.**

Next.js는 바로 이 "경계의 공백"을 메우기 위해 만들어졌다.

**UI를 그리는 시점과 방식에 대한 선택지를 명시화하고, 이를 구조적으로 통제할 수 있는 React 기반의 프레임워크**가 필요했기 때문이다.

---

## 2. 렌더링 방식 4가지

Next.js는 단순한 기능 추가가 아니라,

**“언제, 어디서, 어떻게 렌더링할 것인가”에 대한 전략을 시스템적으로 분리**했다.

### CSR (Client-Side Rendering)

- 모든 HTML은 클라이언트에서 생성
- JavaScript가 로드되기 전에는 화면이 비어 있음
- SPA처럼 작동
- React의 기본 렌더링 방식

### SSR (Server-Side Rendering)

- 매 요청마다 서버에서 HTML을 생성해 응답
- 초기 로딩은 빠르지만 매번 서버가 필요
- `export async function`을 통해 서버 fetch 가능

### ISR (Incremental Static Regeneration)

- 정적 파일로 배포하되, 특정 경로만 일정 주기로 재생성
- 빌드 타임의 정적성과 실시간 업데이트의 절충
- `revalidate` 옵션으로 시간 단위 설정

### SSG (Static Site Generation)

- 앱을 정적으로 미리 렌더링
- 빠르지만 동적 데이터에는 취약
- 전체 페이지가 빌드 타임에 생성됨

---

## 3. 왜 이 네 가지가 필요한가?

> "모든 페이지가 정적일 수는 없고,
> 
> 모든 페이지를 서버에서 실시간 생성하면 비효율적이다."

Next.js는 이 문제에 대해 **"페이지별 전략 선택"**을 가능하게 한다.

- 제품 상세 페이지는 ISR로
- 로그인 후 대시보드는 SSR로
- 정적 블로그는 SSG로
- 내부 라우팅 후 동적 요청은 CSR로

이렇게 **필요한 전략을 구간마다 다르게 선택**할 수 있다는 것이 핵심이다.

---

## 4. CSR/SSR/ISR/SSG의 공통 구조

- 모두 **React 컴포넌트를 기준으로 동작**
- Next.js는 해당 페이지가 어떤 방식으로 렌더링되어야 하는지를 **빌드 시점, 요청 시점, 혹은 클라이언트에서 판단**한다
- 결정은 `fetch`, `getStaticProps`, `generateStaticParams`, `'use client'`, `revalidate` 같은 선언으로 이뤄짐

---

## 5. 결론

Next.js는 단순한 React 확장이 아니다.

**React의 부족한 실행 시점 제어와 SSR 능력을 구조적으로 보완하는 설계 시스템**이다.

CSR/SSR/ISR/SSG는 각각 **시간과 장소, 비용과 속도, 유연성과 성능**을 선택하는 전략이다.

렌더링이 곧 설계다.

**Next.js를 사용한다는 것은 곧, 각 페이지가 어떤 방식으로 사용자에게 전달되어야 하는지를 설계한다는 뜻**일 수밖에 없다.