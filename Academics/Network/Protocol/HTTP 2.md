---
type: academic
---
## 개념

HTTP/2는 HTTP/1.1의 구조적 한계를 해결하기 위해 만들어진 차세대 웹 프로토콜이다. 여전히 TCP 위에서 작동하지만, 메시지를 더 이상 사람이 읽을 수 있는 문자열로 구성하지 않는다. 대신, **모든 데이터를 바이너리 프레임 단위로 쪼개어 전송**한다.

---

## 바이너리 기반이 된 이유

HTTP/1.1은 텍스트 기반이라서 디버깅은 편하지만, 구문 해석이 복잡하고 느리며, 멀티플렉싱 같은 고급 기능을 구현하기엔 구조적으로 한계가 있었다.

HTTP/2는 **애초에 사람 읽기 좋은 형식이 아닌, 기계가 읽기 쉬운 형식**으로 설계되었다. 즉, **바이트 레벨에서 프로토콜의 모든 요소가 명확하게 정의**되어 있어 파싱이 훨씬 빠르고 안전하다.

---

## 메시지 구조

HTTP/2는 모든 데이터를 **프레임(frame)** 단위로 나누어 전송한다. 하나의 요청이나 응답은 여러 프레임으로 구성될 수 있으며, 이 프레임들은 **스트림(stream)**이라는 단위로 묶인다.

### 주요 프레임 종류:

- **HEADERS**: 요청/응답 헤더 정보를 담는다 (HPACK 압축 사용)
- **DATA**: 실제 본문 데이터
- **SETTINGS**: 피어 간 초기 협상용
- **WINDOW_UPDATE**: 흐름 제어 용도
- **PING**, **PRIORITY** 등

---

## 멀티플렉싱

HTTP/1.1에서는 커넥션 하나로 요청 하나씩만 처리 가능했지만, HTTP/2는 하나의 커넥션 안에서 **여러 스트림을 동시에 처리**할 수 있다. 각 프레임에는 스트림 ID가 붙어 있어서, 동시에 여러 요청/응답이 오가도 서로 섞이지 않는다.

---

## 인코딩과 문자 처리

HTTP/2는 내부적으로 바이너리 기반이라 텍스트 인코딩에 대한 의존은 없다. **하지만 여전히 콘텐츠 자체가 문자열일 경우, 인코딩 정보는 필요하다.** 이건 HTTP/1.1과 동일하게 **Content-Type 헤더의 `charset` 속성**으로 명시된다.

```
Content-Type: application/json; charset=utf-8

```

HTTP/2의 헤더는 HPACK이라는 압축 포맷으로 바이너리화되므로, 헤더 자체는 텍스트처럼 보이지 않지만, **내용적으로는 여전히 UTF-8 인코딩 등의 의미가 있다.**

---

## 예시 흐름 (핸드셰이크 이후)

1. TLS 위에서 ALPN을 통해 HTTP/2를 협상함
2. 설정 프레임(SETTINGS) 교환
3. 클라이언트가 스트림 ID 1로 HEADERS, DATA 프레임 전송
4. 서버가 스트림 ID 1로 HEADERS, DATA 프레임 응답
5. 동시에 스트림 ID 3, 5, 7로 다른 요청을 보내도 병렬 처리 가능

---

## HTTP/1.1과 차이점

|항목|HTTP/1.1|HTTP/2|
|---|---|---|
|메시지 구조|텍스트 기반|바이너리 프레임 기반|
|멀티플렉싱|불가 (순차 응답)|가능 (스트림 ID 기반 병렬 처리)|
|헤더|반복, 크고 느림|HPACK 압축, 빠름|
|인코딩 지정|Content-Type charset|동일 방식 사용|
|성능|병목 있음|커넥션 하나로 병렬 처리|

---

## 따라서

HTTP/2는 "텍스트 기반이라는 제약을 버리고", **기계가 효율적으로 처리할 수 있도록 바이너리 구조로 재설계된 프로토콜**이다. 모든 요청과 응답은 프레임 단위로 나뉘고, 이 프레임들은 스트림 ID로 구분되어 하나의 TCP 연결에서 병렬로 오갈 수밖에 없다. 헤더는 압축되고, 흐름 제어도 명시적으로 처리된다.

하지만 콘텐츠가 문자열인 경우엔 여전히 인코딩 문제가 존재하며, 이를 해결하기 위해 Content-Type에 `charset=utf-8` 같은 명시를 꼭 해야 한다. 이건 HTTP/1.1과 동일한 약속이며, 바이너리 구조라고 해서 문자 해석의 문제가 사라지는 건 아니기 때문이다.