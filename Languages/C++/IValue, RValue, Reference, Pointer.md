---
type: language
parent: "[[C++]]"
---

## **1. 값의 종류 (Value Categories)**

C++의 모든 표현식(expression)은 lvalue 또는 rvalue 중 하나로 분류됩니다.

### **lvalue (Left-value)**

- **정의:** 식별 가능한 메모리 위치를 가지는 표현식입니다. 이름이 있고, 주소를 얻을 수 있으며, 여러 번 참조될 수 있습니다.
    
- **핵심 특징:** 생명주기가 길고, 대입문의 왼쪽에 올 수 있습니다.
    
- **예시:** 변수명(`myVar`), 배열의 원소(`arr[0]`), 역참조된 포인터(`*ptr`), lvalue 참조를 반환하는 함수 호출.
    

### **rvalue (Right-value)**

- **정의:** 그 표현식이 끝나는 순간 사라지는 임시적인 값입니다. 식별 가능한 메모리 위치나 이름이 없습니다.
    
- **핵심 특징:** 생명주기가 짧고, 대입문의 오른쪽에만 올 수 있습니다.
    
- **예시:** 리터럴(`10`, `"hello"`), 산술 연산의 결과(`x + y`), 임시 객체를 반환하는 함수 호출.
    

---

## **2. 참조와 값의 관계 (References & Value Categories)**

참조는 이미 존재하는 객체에 대한 별명(alias)입니다. 어떤 종류의 값을 가리킬 수 있는지에 따라 역할이 나뉩니다.

### **lvalue 참조 (`T&`)**

- **규칙:** **오직 lvalue만** 가리킬 수 있습니다.
    
- **주요 용도:**
    
    1. **함수로 객체를 전달하여 수정할 때:** 함수 내에서 원본 객체를 직접 변경하기 위해 사용합니다.
        
        C++
        
        ```
        void increment(int& value) { // value는 lvalue여야 함
            value++;
        }
        int x = 10;
        increment(x); // x는 이제 11
        ```
        
    2. **복사 비용을 피할 때 (읽기/쓰기):** 큰 객체를 함수로 넘길 때 비싼 복사를 피하기 위해 사용합니다.
        
- **사용하면 안 되는 경우:**
    
    - `nullptr`처럼 "없음"을 표현해야 할 때. 참조는 반드시 유효한 객체를 가리켜야 합니다.
        
    - rvalue (리터럴, 임시 객체)를 인자로 받고 싶을 때.
        
        C++
        
        ```
        // increment(10); // 컴파일 에러! 10은 rvalue이다.
        ```
        

### **const lvalue 참조 (`const T&`)**

- **규칙:** **lvalue와 rvalue 모두** 가리킬 수 있습니다.
    
- **주요 용도:**
    
    1. **복사 비용 없이 읽기 전용 접근이 필요할 때:** 가장 일반적인 용도입니다. 함수가 객체를 수정하지 않는다는 계약을 하면서, lvalue와 rvalue를 모두 효율적으로 받을 수 있습니다.
        

- ```
      void print(const std::string& str) { // str은 lvalue, rvalue 모두 가능
          std::cout << str << std::endl;
      }
      std::string myStr = "world";
      print(myStr);   // lvalue 전달
      print("hello"); // rvalue 전달
      ```
    ```
    

- **사용하면 안 되는 경우:**
    
    - 함수 내에서 전달받은 객체의 상태를 변경해야 할 때.
        

### **rvalue 참조 (`T&&`)**

- **규칙:** **오직 rvalue만** 가리킬 수 있습니다.
    
- **주요 용도:**
    
    1. **이동 의미론(Move Semantics) 구현:** 소멸될 임시 객체(rvalue)의 자원을 "훔쳐와서" 비싼 복사를 피합니다. 이동 생성자, 이동 대입 연산자의 핵심입니다.
        
        C++
        
        ```
        std::string str1 = "hello";
        std::string str2 = std::move(str1); // std::move는 lvalue를 rvalue처럼 취급하게 함
        // 이제 str1의 내용은 비어있고, str2가 그 자원을 소유함
        ```
        
    2. **완벽 전달(Perfect Forwarding):** 템플릿 함수에서 인자의 값 종류(lvalue/rvalue)를 그대로 다른 함수로 전달할 때 사용됩니다.
        
- **사용하면 안 되는 경우:**
    
    - lvalue를 받으려 할 때.
        

---

## **3. 포인터와 `const` (Pointers & `const`)**

포인터는 변수의 메모리 주소를 저장합니다. 주소를 가질 수 있는 것은 lvalue뿐이므로, **포인터는 항상 lvalue를 가리킵니다.** `const`의 위치에 따라 의미가 크게 달라집니다.

- **`const T* ptr`** (데이터 상수 포인터)
    
    - **의미:** 포인터가 가리키는 **데이터를 수정할 수 없습니다.** 포인터 자체는 다른 주소를 가리키도록 변경 가능합니다.
        
    - **용도:** 객체의 내용을 읽기만 하고 수정은 하지 않겠다는 것을 명시하며 함수 인자로 전달할 때 사용됩니다.
        
    - **예시:**
        
        C++
        
        ```
        void print_values(const int* arr, int size);
        // *arr = 10; // 함수 내에서 이 코드는 컴파일 에러
        ```
        
- **`T* const ptr`** (포인터 상수)
    
    - **의미:** 포인터가 가리키는 **주소를 변경할 수 없습니다.** 포인터가 가리키는 데이터는 수정 가능합니다.
        
    - **용도:** 클래스 멤버 변수로 포인터를 가질 때, 이 포인터가 객체의 생명주기 동안 항상 동일한 대상을 가리키도록 강제하고 싶을 때 사용됩니다.
        
    - **예시:**
        
        C++
        
        ```
        class HardwareInterface {
            Register* const controlRegister; // 항상 특정 하드웨어 레지스터를 가리킴
        public:
            HardwareInterface(Register* reg) : controlRegister(reg) {}
        };
        ```
        
- **`const T* const ptr`** (데이터/포인터 모두 상수)
    
    - **의미:** 포인터가 가리키는 **데이터와 주소 모두 변경할 수 없습니다.**
        
    - **용도:** 절대 불변이어야 하는 하드웨어 주소나 설정값을 가리킬 때 사용됩니다.