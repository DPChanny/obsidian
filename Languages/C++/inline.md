## **1. 원래 의미: 컴파일러를 위한 성능 최적화 '힌트'**

함수를 호출할 때는 스택에 인자를 쌓고, 함수 주소로 점프했다가 다시 돌아오는 등의 약간의 오버헤드가 발생합니다. `inline` 키워드의 원래 의도는 컴파일러에게 "이 함수는 작고 간단하니, 함수 호출 오버헤드를 없애기 위해 **함수를 호출하는 지점에 함수 본체의 코드를 그냥 복사-붙여넣기 해줘**" 라고 요청하는 것이었습니다.

하지만 **현대 컴파일러는 매우 똑똑**해서, `inline` 키워드가 있든 없든 스스로 판단하여 최적화를 수행합니다. 작은 함수는 알아서 인라이닝하고, `inline`이 붙었어도 너무 큰 함수는 인라이닝하지 않습니다.

> **결론:** 오늘날 성능 최적화만을 목적으로 `inline`을 명시적으로 사용하는 것은 거의 의미가 없습니다.

---

## **2. 현대적 의미: 링커를 위한 '중복 정의 허용' 약속**

이것이 `inline`의 진짜 핵심 역할입니다. `inline`은 C++의 **'단일 정의 규칙(ODR)'에 대한 예외**를 만들어 줍니다.

일반적으로 함수는 프로그램 전체에서 단 한 번만 정의될 수 있습니다. 만약 헤더 파일에 함수 정의를 넣으면, 이 헤더를 여러 `.cpp` 파일에서 `#include`할 때마다 중복 정의가 발생하여 **LNK2005 같은 링커 오류**가 발생합니다.

`inline`은 링커에게 다음과 같이 말해주는 것과 같습니다.

> **"이 함수의 정의는 여러 `.cpp` 파일에 걸쳐 중복으로 존재할 수 있습니다. 이것은 오류가 아니니, 그중 아무거나 하나만 선택하고 나머지는 버려주세요."**

이 약속 덕분에 우리는 **함수의 정의를 헤더 파일에 작성**할 수 있게 됩니다.

- **`my_inline.h`**
    
    C++
    
    ```
    #pragma once
    
    // 이 함수 정의를 헤더에 작성할 수 있는 것은 'inline' 덕분이다.
    inline int add(int a, int b) {
        return a + b;
    }
    ```
    
- **`a.cpp` 와 `b.cpp`**
    
    C++
    
    ```
    #include "my_inline.h"
    // ...
    int result = add(1, 2);
    ```
    

위와 같이 `a.cpp`와 `b.cpp`가 모두 `my_inline.h`를 포함해도, 링커는 `add` 함수의 중복된 정의를 오류로 처리하지 않고 하나로 합쳐줍니다.

### **## 언제 `inline`이 되는가?**

1. **명시적 `inline`:** 함수 앞에 `inline` 키워드를 직접 붙일 때.
    
2. **암시적 `inline`:**
    
    - **클래스/구조체 정의 `{}` 내부에서 구현된 모든 멤버 함수**는 자동으로 `inline` 처리됩니다. (이것이 지금까지 오류를 겪지 않으셨던 이유입니다.)
        
    - **템플릿 함수**는 항상 암시적으로 `inline`입니다.