---
type: language
---
## **1. C++ 표준 스마트 포인터 (`<memory>`)**

### **`std::unique_ptr<T>` (유일한 소유자)**

- **핵심 개념:** 포인터가 가리키는 객체에 대한 **독점적인 소유권**을 가집니다. 오직 하나의 `unique_ptr`만이 특정 객체를 소유할 수 있습니다.
    
- **동작 방식:** `unique_ptr`가 범위를 벗어나 소멸될 때, 자신이 가리키던 객체도 자동으로 `delete` 해줍니다. 복사 대입이 금지되어 있어 소유권이 실수로 복제되는 것을 막습니다.
    
- **주요 용도:**
    
    1. **객체의 생명주기를 특정 범위(스코프)로 한정할 때:** 함수 내에서 생성된 객체가 함수 종료 시 반드시 해제되도록 보장합니다.
        
        C++
        
        ```
        void process() {
            std::unique_ptr<MyObject> p(new MyObject());
            p->DoSomething();
        } // 함수가 끝나면 p가 소멸되면서 MyObject도 자동으로 delete됨
        ```
        
    2. **객체의 소유권을 명시적으로 이전할 때:** `std::move`를 사용해야만 소유권을 다른 `unique_ptr`에게 넘겨줄 수 있습니다.
        
        C++
        
        ```
        std::unique_ptr<MyObject> p1(new MyObject());
        std::unique_ptr<MyObject> p2 = std::move(p1); // p1의 소유권을 p2에게 이전
        // 이제 p1은 nullptr이 되고, p2가 객체를 소유함
        ```
        

### **`std::shared_ptr<T>` (공동 소유자)**

- **핵심 개념:** **참조 카운팅(Reference Counting)** 방식을 통해 여러 개의 `shared_ptr`가 하나의 객체를 **안전하게 공동으로 소유**합니다.
    
- **동작 방식:**
    
    1. 새로운 `shared_ptr`가 객체를 가리키면 참조 카운트가 1 증가합니다.
        
    2. `shared_ptr`가 소멸되거나 다른 객체를 가리키게 되면 참조 카운트가 1 감소합니다.
        
    3. 참조 카운트가 **0이 되는 순간**, 마지막 남은 `shared_ptr`가 객체를 자동으로 `delete` 합니다.
        
- **주요 용도:**
    
    1. **소유권이 명확하지 않거나, 여러 객체가 하나의 데이터를 공유해야 할 때:** 그래프의 노드, 비동기 작업의 콜백 등 누가 마지막 사용자인지 알기 어려울 때 유용합니다.
        
    2. 컨테이너에 포인터를 담아두고, 컨테이너와 외부 코드가 모두 객체를 참조해야 할 때 사용합니다.
        

### **`std::weak_ptr<T>` (관찰자)**

- **핵심 개념:** `shared_ptr`가 관리하는 객체를 **소유권 없이 관찰**만 하는 포인터입니다.
    
- **동작 방식:** `weak_ptr`는 참조 카운트에 영향을 주지 않습니다. 따라서 `weak_ptr`만 남아있다고 해서 객체가 소멸되지 않는 것을 막지는 못합니다. 객체에 접근하려면 반드시 `lock()` 메소드를 통해 유효한 `shared_ptr`로 변환해야 합니다. 만약 객체가 이미 소멸되었다면 `lock()`은 빈 `shared_ptr`(`nullptr`)를 반환합니다.
    
- **주요 용도:**
    
    1. **순환 참조(Circular Reference) 문제 해결:** 두 객체가 서로를 `shared_ptr`로 가리키면, 참조 카운트가 절대 0이 되지 않아 메모리 누수가 발생합니다. 이때 한쪽의 참조를 `weak_ptr`로 바꾸면 순환 고리를 끊을 수 있습니다.
        
        C++
        
        ```
        class B;
        class A { public: std::shared_ptr<B> b_ptr; };
        class B { public: std::weak_ptr<A> a_ptr; }; // B가 A를 약하게 참조
        ```
        
    2. **캐싱(Caching):** 객체가 메모리에 아직 유효하게 존재한다면 접근하고, 아니라면 새로 만드는 등의 로직을 구현할 때 안전하게 사용할 수 있습니다.
        

---

## **2. 언리얼 엔진(UE) 스마트 포인터**

언리얼 엔진은 자체적인 객체 모델(`UObject`)과 가비지 컬렉션(GC) 시스템을 가지고 있어, C++ 표준 스마트 포인터와는 다른 목적의 포인터들을 사용합니다.

### **`TObjectPtr<T>` (UObject용 기본 포인터)**

- **핵심 개념:** UE5부터 `UObject`를 가리키는 Raw 포인터(`T*`)를 대체하는 **기본 스마트 포인터**입니다.
    
- **동작 방식:** 언리얼의 **가비지 컬렉션(GC) 시스템과 긴밀하게 연동**됩니다. `UPROPERTY()` 매크로와 함께 사용되어야 하며, 이를 통해 GC가 해당 객체를 추적할 수 있게 됩니다. 또한, 포인터가 가리키는 객체가 GC에 의해 파괴되면 자동으로 `nullptr`로 설정되어 댕글링 포인터 문제를 방지합니다.
    
- **주요 용도:** 모든 `UObject` 파생 클래스의 멤버 변수로 포인터를 선언할 때 사용합니다.
    
    C++
    
    ```
    UPROPERTY()
    TObjectPtr<AMyActor> TargetActor;
    ```
    

### **`TWeakObjectPtr<T>` (UObject용 약한 참조)**

- **핵심 개념:** C++의 `std::weak_ptr`와 유사하게, `UObject`를 **가비지 컬렉션에 영향을 주지 않고 안전하게 관찰**합니다.
    
- **동작 방식:** 참조 카운트를 증가시키지 않으므로, 이 포인터만으로는 객체의 소멸을 막을 수 없습니다. 객체에 접근하기 전 `IsValid()` 메소드로 유효성을 반드시 확인해야 합니다.
    
- **주요 용도:**
    
    1. 순환 참조 방지.
        
    2. 반드시 존재하지 않아도 되는 선택적인 객체를 참조할 때.
        

### **`TSoftObjectPtr<T>` (지연 로딩용 참조)**

- **핵심 개념:** 아직 메모리에 로드되지 않은 애셋(Asset)을 **경로(문자열)로 참조**하는 포인터입니다.
    
- **동작 방식:** 평소에는 애셋의 경로만 가볍게 저장하고 있다가, 실제로 해당 애셋이 필요한 시점에 비동기적으로 로딩할 수 있는 기능을 제공합니다.
    
- **주요 용도:**
    
    1. **메모리 관리 및 로딩 시간 최적화:** 레벨 시작 시 모든 몬스터의 텍스처를 로드하는 대신, `TSoftObjectPtr`로 참조만 해두었다가 해당 몬스터가 실제로 화면에 등장할 때 비로소 텍스처를 로드하여 초기 로딩 시간을 단축하고 메모리를 절약합니다.
        
    2. 방대한 양의 애셋 목록(예: 데이터 테이블)을 관리할 때 유용합니다.